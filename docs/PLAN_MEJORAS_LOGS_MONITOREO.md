# üîß PLAN DE MEJORAS - LOGS Y MONITOREO

**Fecha**: 17 de octubre, 2025  
**Basado en**: FASE_5.5_AUDITORIA_LOGS_MONITOREO.md  
**Objetivo**: Mejorar sistema de logging y monitoreo para producci√≥n

---

## üéØ RESUMEN EJECUTIVO

### Problemas Identificados
1. ‚ö†Ô∏è **Console.log en producci√≥n** (15+ archivos afectados)
2. ‚ö†Ô∏è **Logger estructurado no utilizado** (existe pero ignorado)
3. üî¥ **Sin error tracking** (errores se pierden)
4. üî¥ **Sin monitoreo en producci√≥n** (ceguera operacional)

### Impacto sin Mejoras
```
‚ùå Debugging dif√≠cil en producci√≥n
‚ùå Errores invisibles hasta que usuarios reportan
‚ùå Logs contaminados con debug info
‚ùå No hay m√©tricas de salud del sistema
‚ùå MTTR (Mean Time To Repair) alto
```

### ROI de Implementaci√≥n
```
‚úÖ 80% reducci√≥n en tiempo de debugging
‚úÖ Detecci√≥n proactiva de errores
‚úÖ Mejor experiencia de soporte
‚úÖ Datos para mejora continua
‚úÖ Alertas autom√°ticas 24/7
```

---

## üöÄ PRIORIDAD 1: LIMPIEZA DE CONSOLE.LOG (CR√çTICO)

### üéØ Objetivo
Eliminar console.log de c√≥digo de producci√≥n para tener logs limpios.

### üìä Alcance
- **Archivos afectados**: 15+
- **Tiempo estimado**: 2 horas
- **Impacto**: Alto (limpieza de logs)
- **Complejidad**: Baja

### üìù Tareas Espec√≠ficas

#### 1. Limpiar API Routes
**Archivos**:
- `app/api/zones/route.ts` (9 console.log ‚Üí eliminar)
- `app/api/table-layout/route.ts` (2 console.error ‚Üí migrar)
- `app/api/tables/by-token/[token]/route.ts` (1 console.error ‚Üí migrar)

**Acci√≥n**:
```typescript
// ‚ùå ANTES
console.log('[GET /api/zones] Iniciando petici√≥n...')
console.log('[GET /api/zones] ‚úÖ Usuario autenticado:', user.id)
console.log('[GET /api/zones] ‚úÖ Zonas obtenidas:', zones?.length || 0)

// ‚úÖ DESPU√âS
// Eliminar completamente o migrar a logger.debug() si es cr√≠tico
```

#### 2. Limpiar P√°ginas
**Archivos**:
- `app/dashboard/page.tsx` (11 console.log ‚Üí eliminar)
- `app/menu/page.tsx` (5 console.log ‚Üí eliminar)

**Acci√≥n**:
```typescript
// ‚ùå ANTES (dashboard/page.tsx)
console.log('üîç Dashboard useEffect ejecutado', { ... })
console.log('üìä Cargando m√©tricas para tenant:', user.tenant_id)
console.log('‚úÖ M√©tricas cargadas:', data)

// ‚úÖ DESPU√âS
// Eliminar todos los console.log de debugging
```

#### 3. Script de Limpieza
```bash
# Crear script para encontrar console.log restantes
# scripts/check-console-logs.sh

#!/bin/bash
echo "Buscando console.log en producci√≥n..."
grep -r "console.log" app/ --include="*.ts" --include="*.tsx" | grep -v "node_modules"
```

### ‚úÖ Criterio de √âxito
- [ ] 0 console.log en `app/api/**/*.ts`
- [ ] 0 console.log en `app/**/page.tsx` (excepto comentados)
- [ ] console.error permitido solo en bloques catch cr√≠ticos
- [ ] Script de verificaci√≥n pasa sin warnings

---

## üîß PRIORIDAD 2: ADOPTAR LOGGER ESTRUCTURADO (CR√çTICO)

### üéØ Objetivo
Usar el logger estructurado existente en lugar de console.log/error directo.

### üìä Alcance
- **Archivos afectados**: 20+
- **Tiempo estimado**: 3 horas
- **Impacto**: Alto (logs estructurados)
- **Complejidad**: Media

### üìù Implementaci√≥n Paso a Paso

#### Paso 1: Migrar API Routes a Logger

**Archivo**: `app/api/zones/route.ts`

```typescript
// ‚úÖ A√ëADIR al inicio
import { createLogger } from '@/lib/logger'

const logger = createLogger('api:zones')

// ‚úÖ REEMPLAZAR en funciones
export async function GET(request: Request) {
  try {
    const user = await getCurrentUser()
    if (!user) {
      logger.warn('Unauthenticated access attempt')
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const tenantId = getTenantIdFromUser(user)
    if (!tenantId) {
      logger.error('User without tenant_id', undefined, { userId: user.id })
      return NextResponse.json({ error: 'No tenant' }, { status: 400 })
    }

    const supabase = createServerClient()
    const { data: zones, error } = await supabase
      .from('zones')
      .select('*')
      .eq('tenant_id', tenantId)
      .eq('active', true)
      .order('sort_order', { ascending: true })

    if (error) {
      logger.error('Failed to fetch zones', error, { tenantId })
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    logger.info('Zones fetched successfully', { 
      tenantId, 
      count: zones?.length || 0 
    })

    return NextResponse.json({ data: zones })
  } catch (error) {
    logger.error('Unexpected error in GET /api/zones', error as Error)
    return NextResponse.json({ error: 'Internal error' }, { status: 500 })
  }
}
```

#### Paso 2: Migrar Contexts

**Archivo**: `contexts/auth-context.tsx`

```typescript
// ‚úÖ A√ëADIR
import { createLogger } from '@/lib/logger'

const logger = createLogger('auth-context')

// ‚úÖ REEMPLAZAR
// ‚ùå console.warn('[loadUserData] No access token found...')
logger.warn('No access token found, relying on cookies only', {
  hasSession: !!session
})

// ‚ùå console.warn('[loadUserData] Timeout de 10 segundos alcanzado')
logger.warn('User data load timeout', {
  timeout: 10000,
  userId: session?.user?.id
})
```

#### Paso 3: Migrar Hooks

**Archivo**: `app/pedidos/_hooks/use-orders-panel.ts`

```typescript
import { createLogger } from '@/lib/logger'

const logger = createLogger('orders-panel')

// ‚úÖ REEMPLAZAR
catch (error) {
  // ‚ùå console.error("[useOrdersPanel]", error)
  logger.error('Failed to load orders', error as Error, {
    tableId,
    filters: activeFilters
  })
}
```

### üì¶ Template de Logger por M√≥dulo

```typescript
// Template para nuevos archivos
import { createLogger } from '@/lib/logger'

// Nombrar seg√∫n el m√≥dulo (kebab-case)
const logger = createLogger('module-name')

// Uso en funciones
try {
  // Operaci√≥n
  logger.info('Operation successful', { data })
} catch (error) {
  logger.error('Operation failed', error as Error, { context })
  throw error
}
```

### ‚úÖ Criterio de √âxito
- [ ] Todos los API routes usan logger
- [ ] Contexts cr√≠ticos usan logger
- [ ] Hooks principales usan logger
- [ ] Formato consistente en todos los logs
- [ ] Contexto rico en logs de error

---

## üö® PRIORIDAD 3: INTEGRAR ERROR TRACKING (CR√çTICO)

### üéØ Objetivo
Capturar y reportar errores autom√°ticamente con Sentry.

### üìä Alcance
- **Servicio**: Sentry (recomendado)
- **Tiempo estimado**: 2 horas
- **Impacto**: Muy Alto (visibilidad de errores)
- **Complejidad**: Media

### üîß Implementaci√≥n con Sentry

#### Paso 1: Instalaci√≥n
```bash
npm install @sentry/nextjs
npx @sentry/wizard@latest -i nextjs
```

Esto crear√° autom√°ticamente:
- `sentry.client.config.ts`
- `sentry.server.config.ts`
- `sentry.edge.config.ts`
- Actualizar√° `next.config.js`

#### Paso 2: Configuraci√≥n B√°sica

**Archivo**: `sentry.client.config.ts`
```typescript
import * as Sentry from "@sentry/nextjs"

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  
  // Performance Monitoring
  tracesSampleRate: 1.0, // 100% en desarrollo, 0.1 en producci√≥n
  
  // Session Replay
  replaysSessionSampleRate: 0.1, // 10% de sesiones normales
  replaysOnErrorSampleRate: 1.0, // 100% cuando hay error
  
  integrations: [
    new Sentry.BrowserTracing({
      tracePropagationTargets: [
        "localhost",
        /^https:\/\/yourapp\.com/
      ],
    }),
    new Sentry.Replay({
      maskAllText: true,
      blockAllMedia: true,
    }),
  ],
  
  environment: process.env.NODE_ENV,
  
  // Filtrar errores conocidos
  ignoreErrors: [
    'ResizeObserver loop limit exceeded',
    'Non-Error promise rejection captured',
  ],
  
  // Enriquecer contexto
  beforeSend(event, hint) {
    // A√±adir contexto custom
    if (event.user) {
      event.user = {
        ...event.user,
        tenant_id: localStorage.getItem('tenant_id')
      }
    }
    return event
  }
})
```

**Archivo**: `sentry.server.config.ts`
```typescript
import * as Sentry from "@sentry/nextjs"

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  tracesSampleRate: 1.0,
  environment: process.env.NODE_ENV,
  
  // Server-specific config
  debug: false,
})
```

#### Paso 3: Variables de Entorno

**Archivo**: `.env.local`
```env
# Sentry Configuration
NEXT_PUBLIC_SENTRY_DSN=https://your-dsn@sentry.io/project-id
SENTRY_AUTH_TOKEN=your-auth-token
SENTRY_ORG=your-org
SENTRY_PROJECT=restaurant-management
```

#### Paso 4: Mejorar Error Boundary

**Archivo**: `components/error-boundary.tsx`
```typescript
"use client"

import { Component, type ReactNode, type ErrorInfo } from "react"
import * as Sentry from "@sentry/nextjs"
import { createLogger } from "@/lib/logger"

const logger = createLogger('error-boundary')

interface Props {
  children: ReactNode
  fallback?: ReactNode
}

interface State {
  hasError: boolean
  error?: Error
  errorInfo?: ErrorInfo
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // ‚úÖ Log estructurado
    logger.error('React error boundary caught error', error, {
      componentStack: errorInfo.componentStack,
      route: typeof window !== 'undefined' ? window.location.pathname : 'unknown',
    })

    // ‚úÖ Enviar a Sentry con contexto completo
    Sentry.withScope((scope) => {
      scope.setContext('react', {
        componentStack: errorInfo.componentStack,
      })
      scope.setContext('location', {
        pathname: typeof window !== 'undefined' ? window.location.pathname : 'unknown',
        search: typeof window !== 'undefined' ? window.location.search : '',
      })
      Sentry.captureException(error)
    })

    this.setState({ errorInfo })
  }

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback
      }

      return (
        <div className="flex items-center justify-center min-h-[400px] p-4">
          <Card className="w-full max-w-md">
            <CardHeader className="text-center">
              <div className="mx-auto mb-4 flex h-12 w-12 items-center justify-center rounded-full bg-destructive/10">
                <AlertTriangle className="h-6 w-6 text-destructive" />
              </div>
              <CardTitle>Algo sali√≥ mal</CardTitle>
              <CardDescription>
                Ha ocurrido un error inesperado. Nuestro equipo ha sido notificado.
              </CardDescription>
            </CardHeader>
            <CardContent className="text-center space-y-2">
              <Button 
                onClick={() => window.location.reload()} 
                className="w-full"
              >
                <RefreshCw className="mr-2 h-4 w-4" />
                Recargar p√°gina
              </Button>
              
              {process.env.NODE_ENV === 'development' && this.state.error && (
                <details className="mt-4 text-left">
                  <summary className="cursor-pointer text-sm text-muted-foreground">
                    Detalles t√©cnicos
                  </summary>
                  <pre className="mt-2 text-xs bg-muted p-2 rounded overflow-auto">
                    {this.state.error.toString()}
                    {this.state.errorInfo?.componentStack}
                  </pre>
                </details>
              )}
            </CardContent>
          </Card>
        </div>
      )
    }

    return this.props.children
  }
}
```

#### Paso 5: Usar Error Boundary en Layout

**Archivo**: `app/layout.tsx`
```typescript
import { ErrorBoundary } from '@/components/error-boundary'

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="es">
      <body>
        <ErrorBoundary>
          {children}
        </ErrorBoundary>
      </body>
    </html>
  )
}
```

#### Paso 6: Captura Manual en API Routes

```typescript
import * as Sentry from "@sentry/nextjs"
import { createLogger } from '@/lib/logger'

const logger = createLogger('api:example')

export async function POST(request: Request) {
  try {
    // Operaci√≥n
  } catch (error) {
    // Log estructurado
    logger.error('API operation failed', error as Error, {
      method: request.method,
      url: request.url
    })

    // Enviar a Sentry con contexto
    Sentry.withScope((scope) => {
      scope.setContext('request', {
        method: request.method,
        url: request.url,
      })
      Sentry.captureException(error)
    })

    return NextResponse.json({ error: 'Internal error' }, { status: 500 })
  }
}
```

### üìä Configurar Alertas en Sentry

1. **Email notifications**: Errores nuevos o picos de frecuencia
2. **Slack integration**: Canal #alerts para errores cr√≠ticos
3. **Issue assignment**: Auto-asignar por m√≥dulo/ruta
4. **Release tracking**: Asociar errores con versiones

### ‚úÖ Criterio de √âxito
- [ ] Sentry instalado y configurado
- [ ] Source maps funcionando (ver stack traces correctos)
- [ ] Error boundary enviando a Sentry
- [ ] API routes capturando excepciones
- [ ] Alertas configuradas para errores cr√≠ticos
- [ ] Contexto de usuario en errores (tenant_id, etc.)

---

## üìä PRIORIDAD 4: MONITOREO DE LOGS (IMPORTANTE)

### üéØ Objetivo
Implementar sistema de logs centralizado para producci√≥n.

### üìä Alcance
- **Servicio**: Logtail o similar
- **Tiempo estimado**: 3 horas
- **Impacto**: Alto (observabilidad)
- **Complejidad**: Media

### üîß Implementaci√≥n con Logtail

#### Paso 1: Instalaci√≥n
```bash
npm install @logtail/node @logtail/next
```

#### Paso 2: Extender Logger Existente

**Archivo**: `lib/logger.ts` (modificar)
```typescript
import { Logtail } from "@logtail/node"

// Inicializar Logtail solo en producci√≥n
const logtail = process.env.NODE_ENV === 'production' && process.env.LOGTAIL_TOKEN
  ? new Logtail(process.env.LOGTAIL_TOKEN)
  : null

class Logger {
  private write(entry: LogEntry): void {
    if (!this.shouldLog(entry.level)) {
      return
    }

    // Console output (desarrollo)
    if (process.env.NODE_ENV !== 'production') {
      const output = this.format(entry)
      console[entry.level](output)
    }

    // Logtail (producci√≥n)
    if (logtail) {
      const logData = {
        message: entry.message,
        level: entry.level,
        module: this.config.moduleName,
        timestamp: entry.timestamp,
        ...entry.context,
      }

      if (entry.error) {
        logData.error = {
          name: entry.error.name,
          message: entry.error.message,
          stack: entry.error.stack,
        }
      }

      logtail[entry.level](logData)
    }
  }
}
```

#### Paso 3: Variables de Entorno

**Archivo**: `.env.local`
```env
# Logtail Configuration
LOGTAIL_TOKEN=your-logtail-token-here
```

#### Paso 4: Flush en Server Shutdown

**Archivo**: `lib/logger.ts` (a√±adir)
```typescript
// Asegurar que logs se env√≠en antes de shutdown
if (logtail && typeof process !== 'undefined') {
  process.on('beforeExit', async () => {
    await logtail.flush()
  })
}

export async function flushLogs(): Promise<void> {
  if (logtail) {
    await logtail.flush()
  }
}
```

#### Paso 5: Configurar Dashboards en Logtail

1. **Dashboard de Errores**:
   - Gr√°fico de errores por hora
   - Top 10 errores m√°s frecuentes
   - Errores por m√≥dulo

2. **Dashboard de Performance**:
   - Logs de operaciones lentas
   - Requests por minuto
   - Latencia de API routes

3. **Dashboard de Usuarios**:
   - Logins por d√≠a
   - Errores por tenant
   - Actividad por usuario

#### Paso 6: Configurar Alertas

```sql
-- Query para alertas en Logtail
-- Alerta: M√°s de 10 errores en 5 minutos
SELECT COUNT(*) as error_count
FROM logs
WHERE level = 'error'
  AND dt > NOW() - INTERVAL '5 minutes'
HAVING error_count > 10

-- Alerta: Error en pago
SELECT *
FROM logs
WHERE level = 'error'
  AND message LIKE '%payment%'
  AND dt > NOW() - INTERVAL '1 minute'

-- Alerta: Usuario sin tenant_id
SELECT *
FROM logs
WHERE message LIKE '%No tenant%'
  AND dt > NOW() - INTERVAL '5 minutes'
```

### ‚úÖ Criterio de √âxito
- [ ] Logtail integrado en logger
- [ ] Logs fluyendo a Logtail en producci√≥n
- [ ] Dashboards creados (errores, performance, usuarios)
- [ ] Alertas configuradas para eventos cr√≠ticos
- [ ] Retention configurado (30 d√≠as m√≠nimo)

---

## üìã TIMELINE DE IMPLEMENTACI√ìN

### Semana 1: Cr√≠ticos (Prioridad 1 y 2)
```
D√≠a 1-2: Limpieza de console.log (2h)
  ‚îú‚îÄ Limpiar API routes
  ‚îú‚îÄ Limpiar p√°ginas
  ‚îî‚îÄ Script de verificaci√≥n

D√≠a 3-4: Adoptar logger estructurado (3h)
  ‚îú‚îÄ Migrar API routes
  ‚îú‚îÄ Migrar contexts
  ‚îú‚îÄ Migrar hooks
  ‚îî‚îÄ Verificar consistency
```

### Semana 2: Error Tracking (Prioridad 3)
```
D√≠a 1: Setup Sentry (2h)
  ‚îú‚îÄ Instalaci√≥n y configuraci√≥n
  ‚îú‚îÄ Variables de entorno
  ‚îî‚îÄ Verificar funcionamiento

D√≠a 2: Integraci√≥n completa (2h)
  ‚îú‚îÄ Mejorar error boundary
  ‚îú‚îÄ A√±adir a API routes
  ‚îú‚îÄ Configurar alertas
  ‚îî‚îÄ Testing
```

### Semana 3: Monitoreo (Prioridad 4)
```
D√≠a 1-2: Setup Logtail (3h)
  ‚îú‚îÄ Instalaci√≥n
  ‚îú‚îÄ Extender logger
  ‚îú‚îÄ Variables de entorno
  ‚îî‚îÄ Verificar flujo de logs

D√≠a 3: Dashboards y Alertas (2h)
  ‚îú‚îÄ Crear dashboards
  ‚îú‚îÄ Configurar alertas
  ‚îî‚îÄ Documentar queries
```

---

## üí∞ ESTIMACI√ìN DE COSTOS

### Sentry (Error Tracking)
```
Free Tier:
- 5,000 errors/mes
- 10,000 performance units/mes
- 30 d√≠as de retenci√≥n
- ‚úÖ Suficiente para MVP

Team Plan ($26/mes):
- 50,000 errors/mes
- 100,000 performance units/mes
- 90 d√≠as de retenci√≥n
- Recommended para producci√≥n
```

### Logtail (Log Management)
```
Free Tier:
- 1 GB/mes
- 3 d√≠as de retenci√≥n
- ‚ö†Ô∏è Limitado

Starter ($7/mes):
- 5 GB/mes
- 7 d√≠as de retenci√≥n
- ‚úÖ Suficiente para MVP

Growth ($25/mes):
- 25 GB/mes
- 30 d√≠as de retenci√≥n
- Recommended para producci√≥n
```

### Total Mensual
```
MVP (Free tiers): $0/mes
Producci√≥n (Sentry Team + Logtail Growth): ~$50/mes

ROI: Ahorro de 10-20 horas/mes en debugging = $500-1000/mes
```

---

## üìä M√âTRICAS DE √âXITO

### KPIs T√©cnicos
```
Antes:
‚ùå Console.log en producci√≥n: 15+ archivos
‚ùå Errores sin tracking: 100%
‚ùå MTTR: 2-4 horas
‚ùå Detecci√≥n de errores: Reactiva (usuarios reportan)

Despu√©s:
‚úÖ Console.log en producci√≥n: 0 archivos
‚úÖ Errores con tracking: 100%
‚úÖ MTTR: 15-30 minutos
‚úÖ Detecci√≥n de errores: Proactiva (alertas autom√°ticas)
```

### KPIs de Negocio
```
‚úÖ Reducci√≥n 80% en tiempo de soporte
‚úÖ Incremento en satisfacci√≥n de usuarios
‚úÖ Detecci√≥n temprana de problemas cr√≠ticos
‚úÖ Datos para mejora continua
```

---

## ‚úÖ CHECKLIST FINAL

### Pre-Producci√≥n (Obligatorio)
- [ ] Console.log eliminados de producci√≥n
- [ ] Logger estructurado adoptado
- [ ] Sentry instalado y funcionando
- [ ] Error boundary mejorado
- [ ] Source maps configurados

### Producci√≥n (Recomendado)
- [ ] Logtail o similar integrado
- [ ] Dashboards configurados
- [ ] Alertas funcionando
- [ ] Documentaci√≥n de runbooks
- [ ] Proceso de on-call definido

### Post-Lanzamiento (Opcional)
- [ ] APM (Application Performance Monitoring)
- [ ] Distributed tracing
- [ ] Custom metrics
- [ ] Automated incident response

---

## üéØ CONCLUSI√ìN

### Implementaci√≥n M√≠nima (MVP)
```
‚úÖ Limpieza console.log (2h)
‚úÖ Adoptar logger (3h)
‚úÖ Sentry b√°sico (2h)

Total: 7 horas
Costo: $0/mes (free tiers)
```

### Implementaci√≥n Recomendada (Producci√≥n)
```
‚úÖ Todo lo anterior
‚úÖ Logtail integrado (3h)
‚úÖ Dashboards y alertas (2h)

Total: 12 horas
Costo: ~$50/mes
ROI: 10-20x en ahorro de tiempo
```

### Prioridad de Implementaci√≥n
1. üî¥ **CR√çTICO**: Limpieza console.log + Logger
2. üî¥ **CR√çTICO**: Sentry para error tracking
3. üü° **IMPORTANTE**: Logtail para logs
4. üü¢ **NICE TO HAVE**: APM y m√©tricas avanzadas

---

**Pr√≥ximo Paso**: ¬øQuieres que implemente alguna de estas mejoras ahora o continuamos con la Fase 5.6 (Documentaci√≥n)?
